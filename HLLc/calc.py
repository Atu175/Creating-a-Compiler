# -----------------------------------------------------------------------------# calc.py## A simple calculator with variables.   This is from O'Reilly's# "Lex and Yacc", p. 63.# -----------------------------------------------------------------------------# 2021-10-19, DMW and CSC386 Students, added functions to the calculator application# 2021-10-14, DMW, added sind and sin as part of the in class demonstration# 2021-05-25, DMW, extensively updated with functions, like factoria1, log, ln, exp, int, float, etc.# 2021-05-25, DMW, retrieved from:# https://raw.githubusercontent.com/dabeaz/ply/master/example/calc/calc.pyimport mathimport sysfrom anytree import Node, RenderTreesys.path.insert(0, "../..")# comman constantPI2 = math.pi * 2 # 2021-05-29, DMW, added this constant# 2021-05-29, DMW, let's create reserved wordsreserved = {    'quit': 'QUIT',    'abs': 'ABS',    'sgn': 'SGN',    'int': 'INT',    'float': 'FLOAT',    'pi': 'PI',    'pi2': 'PI2',    'exp': 'EXP',    'ln': 'LN',    'log': 'LOG',    'sin': 'SIN',    'sind': 'SIND',    'cos': 'COS',  # 2021-10-19, DMW, suggested by Collins    'tan': 'TAN',  # 2021-10-19, DMW, suggested by Lisandro    'fib': 'FIB',  # 2021-10-19, DMW, suggested by Ebenezer    'perm': 'PERM',  # 2021-10-19, DMW, suggested by Kristi    #'if': 'IF',  # 2021-10-21, DMW, this statement can't be implemented easily without a parse tree    #'else': 'ELSE',  #2021-10-21, DMW, removed for same reason as "if"    'true': 'TRUE',  # 2021-10-21, DMW, added this boolean constant    'false': 'FALSE'  # 2021-10-21, DMW added this boolean constant}# 2021-05-29, DMW, change tokens from tuple to listtokens = [    'NAME', 'NUMBER', 'INTDIV', # 'EQUALS', 'LESSTHAN', 'GREATERTHAN', 'LTEQ', 'GTEQ',    'EQ', 'LT', 'GT', 'LTEQ', 'GTEQ',    'COMMENT']tokens += list(reserved.values())# 2021-05-25, added ^ and @# 2021-05-29, added ! for factorialliterals = ['=', '+', '-', '*', '/', '^', '(', ')', '!', '@', '?', ':', '%', '#', '{', '}', ',']# Tokens# 2021-10-21, DMW, added the true/false constant tokenst_TRUE = r'true't_FALSE = r'false'def t_EQ(t):    '=='    return tdef t_LT(t):    '<'    return tdef t_GT(t):    '>'    return tdef t_LTEQ(t):    '<='    return tdef t_GTEQ(t):    '>='    return tdef t_INTDIV(t):    '//'    return tdef t_COMMENT(t):    r'\#.*'    pass# 2021-10-21, DMW, removed tokens for both if/else because the implementation is more complicated# 2021-10-15, DMW, if and else token added#def t_IF(t):#    'if'#    return t#def t_ELSE(t):#    'else'#    return t# 2021-10-19, DMW, added permutation token suggested by Kristidef t_PERM(t):    r'perm'    return t# 2021-10-14, DMW, a sin function that works with degrees# this tokenising function has to come BEFORE the shorter function of a similar name SIN# evidently, it doesn't matter if a regex is used over a literal string for matching.def t_SIND(t):    r'sind'    return t# 2021-10-14, DMW, a sin function that works with radiansdef t_SIN(t):    r'sin'    return t# 2021-10-19, DMW, Collins suggest a COS function that works with radiansdef t_COS(t):    r'cos'    return t# 2021-10-19, DMW, Lisandro suggest a TAN function that works with radiansdef t_TAN(t):    r'tan'    return t# t_NAME = r'[a-zA-Z_][a-zA-Z0-9_]*'# 2021-05-29, DMW, rewrote token NAME, check for reserved wordsdef t_NAME(t):    r'[a-zA-Z_][a-zA-Z0-9_]*'    t.type = reserved.get(t.value, 'NAME')    # Check for reserved words    return t# 2021-05-29, DMW, helper function create a Python int or float as neededdef strToNum(s):    ans = 0    try:        ans = int(s)    except ValueError:        ans = float(s)    return ansdef t_NUMBER(t):    r'[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?'    # 2021-05-29, DMW, regular expression is from:    # https://www.regular-expressions.info/floatingpoint.html    #r'\d+' # original regular expression    t.value = strToNum(t.value) # int(t.value)    return tt_ignore = " \t"def t_newline(t):    r'\n+'    t.lexer.lineno += t.value.count("\n")def t_error(t):    print("Illegal character '%s'" % t.value[0])    t.lexer.skip(1)def t_QUIT(t):    'quit'    return tdef t_ABS(t):    'abs'    return tdef t_FIB(t):    r'fib'    return tdef t_SGN(t):    'sqn'    return tdef t_INT(t):    'int'    return tdef t_FLOAT(t):    'float'    return tdef t_PI(t):    'pi'    return tdef t_PI2(t):    'pi2'    return tdef t_EXP(t):    'exp'    return tdef t_LN(t):    'ln'    return tdef t_LOG(t):    'log'    return t# EOF handling ruledef t_eof(t):    return None# Build the lexerimport ply.lex as lexlexer = lex.lex()# ----------------------------------------------------------------------------- PARSER / GRAMMAR / PRODUCTIONS# Parsing rules# 2021-05-29, DMW, added '!' to precedence for factorialprecedence = (    ('nonassoc', '?', ':'), # 'EQUALS', 'LESSTHAN', 'GREATERTHAN', 'LTEQ', 'GTEQ',    ('left', 'EQ', 'LT', 'GT', 'LTEQ', 'GTEQ'),    ('left', '+', '-'),    ('left', '*', '/', '%', 'INTDIV'),    ('left', '!', '^'), # added ^ with higher precedence than *, /    ('right', 'UMINUS'),)# dictionary of namesnames = {}def p_statement_assign(p):    'statement : NAME "=" expression'    names[p[1]] = p[3]def p_statement_expr(p):    'statement : expression'    print(p[1])# 2021-05-25, DMW, added the @ function which shows all the defined namesdef p_statement_list(p):    'statement : "@"'    print(names)# 2021-05-29, DMW, added the quit tokendef p_statement_quit(p):    'statement : QUIT'    sys.exit(0)def p_statement_comment(p):    'statement : COMMENT'    pass# 2021-10-21, DMW, the if statement implemented this way does not work correctly.# it is executing both the true and false blocks creating ambiguity# this is because the inner statements of both true and false execute BEFORE the decision is made# which block (true, or false) should be followed and executed#def p_statement_if(p):#    '''statement : IF expression "{" statement "}" ELSE "{" statement "}"'''#    if p[2]:#        print("@if:true")#        tmp = p[4]#        #p[0] = p[4]#    else:#        print("@if:false")#        tmp = p[8]#        #p[0] = p[8]#    p[0] = tmp#    print("@if")# 2021-10-21, DMW, added the if with no else version of the if statement#                  | IF expr "{" statement "}"'''#def p_statement_if2(p):#    '''statement : IF expression "{" statement "}" '''#    if p[2]:#        p[0] = p[4]#    print("@if2")# 2021-05-25, DMW, added the ^ (exponentiation) operatordef p_expression_binop(p):    '''expression : expression '+' expression                  | expression '-' expression                  | expression '*' expression                  | expression '/' expression                  | expression '^' expression                  | expression '%' expression'''    if p[2] == '+':        p[0] = p[1] + p[3]    elif p[2] == '-':        p[0] = p[1] - p[3]    elif p[2] == '*':        p[0] = p[1] * p[3]    elif p[2] == '/':        p[0] = p[1] / p[3]    elif p[2] == '^':        p[0] = p[1] ** p[3]    elif p[2] == '%':        p[0] = p[1] % p[3]def conditional(c):    return 1 if c else 0def p_expr_conditional_eq(p):    "expression : expression EQ expression"    p[0] = 1 if p[1] == p[3] else 0def p_expr_lt(p):    "expression : expression LT expression"    p[0] = 1 if p[1] < p[3] else 0def p_expr_gt(p):    "expression : expression GT expression"    p[0] = 1 if p[1] > p[3] else 0def p_expr_lteq(p):    "expression : expression LTEQ expression"    p[0] = 1 if p[1] <= p[3] else 0def p_expr_tertiary(p):    "expression : expression '?' expression ':' expression"    p[0] = p[3] if p[1] else p[5]def p_expr_gteq(p):    "expression : expression GTEQ expression"    p[0] = 1 if p[1] >= p[3] else 0def p_expression_uminus(p):    "expression : '-' expression %prec UMINUS"    p[0] = -p[2]def p_expr_intdiv(p):    "expression : expression INTDIV expression"    p[0] = p[1] // p[3]# a recursive factorial functiondef factorial(n):    if (n > 1):        return n * factorial(n - 1)    return 1def p_expr_mono_op(p):    '''expression : expression "!"'''    p[0] = factorial(p[1])def p_expression_group(p):    "expression : '(' expression ')'"    p[0] = p[2]def p_expression_number(p):    "expression : NUMBER"    p[0] = p[1]def p_expression_name(p):    "expression : NAME"    try:        p[0] = names[p[1]]    except LookupError:        print("Undefined name '%s'" % p[1])        p[0] = 0def abs(n):    return n if n >= 0 else -ndef p_expr_abs(p):    "expression : ABS '(' expression ')'"    p[0] = abs(p[3])def p_expr_sgn(p):    "expression : SGN '(' expression ')'"    if p[3] == 0:        p[0] = 0    elif p[3] < 0:        p[0] = -1    else:        p[0] = 1def p_expr_int(p):    "expression : INT '(' expression ')'"    p[0] = int(p[3])def p_expr_float(p):    "expression : FLOAT '(' expression ')'"    p[0] = float(p[3])def p_expr_pi(p):    "expression : PI"    p[0] = math.pidef p_expr_pi2(p):    "expression : PI2"    p[0] = PI2# 2021-10-21, DMW, added productions for true and falsedef p_expr_true(p):    "expression : TRUE"    p[0] = Truedef p_expr_false(p):    "expression : FALSE"    p[0] = Falsedef p_expr_exp(p):    "expression : EXP '(' expression ')'"    p[0] = math.exp(p[3])def p_expr_ln(p):    "expression : LN '(' expression ')'"    p[0] = math.log(p[3])# 2021-10-14, DMW, class added the sin() functiondef p_sin(p):    "expression : SIN '(' expression ')'"    p[0] = math.sin(p[3])# 2021-10-14, DMW, class added the sin() functiondef p_cos(p):    "expression : COS '(' expression ')'"    p[0] = math.cos(p[3])# 2021-10-14, DMW, class added the perm() functiondef p_perm(p):    "expression : PERM '(' expression ',' expression ')'"    p[0] = factorial(p[3]) / factorial(p[3] - p[5])# 2021-10-14, DMW, recursive implementation of fibonoccidef fib(x):    if x < 0:        #raise ValueError("Invalid value.")        print("Value error.")    if x < 2:        return x    return fib(x-1) + fib(x-2)# 2021-10-14, DMW, class added the fib() functiondef p_fib(p):    "expression : FIB '(' expression ')'"    p[0] = fib(p[3])# 2021-10-14, DMW, class added the sin() functiondef p_tan(p):    "expression : TAN '(' expression ')'"    p[0] = math.tan(p[3])def p_sind(p):    "expression : SIND '(' expression ')'"    p[0] = math.sin(p[3] * math.pi / 180)def p_expr_log(p):    "expression : LOG '(' expression ')'"    p[0] = math.log(p[3]) / math.log(10)def p_error(p):    if p:        print("Syntax error at '%s'" % p.value)    else:        print("Syntax error at EOF")import ply.yacc as yaccparser = yacc.yacc()while True:    try:        s = input('calc > ')    except EOFError:        break    if not s:        continue    root = Node("root")    yacc.parse(s)